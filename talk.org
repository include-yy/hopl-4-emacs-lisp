Everyone has a 1h slot, apparently, so that's about 45min for the talk
plus 15min for questions.

There are 5minutes in the plan below, but I suspect that the XEmacs and
post-XEmacs period could be cut down significantly, and or partly merged
into the previous parts

* Stefan

** Background              10min

*** Emacs                   8min
- TECO Emacs => Multics Emacs => Gosling Emacs => GNU Emacs
- ELisp designed as the implementation language of Emacs
- Free Software philosophy embodied in the design
- Development model
  - During TECO Emacs => early GNU Emacs
  - Around Emacs-19 (schism and such)
  - in XEmacs
  - in Emacs≥21

*** Early language design   2min
- maclisp
- mocklisp

** Base ELisp              10min

*** "Normal" language       5min
- scoping
- macros
- absence of records/structs/...
- non-local exits

*** Emacs-specific          5min
- hooks
- docstrings
- interactive functions
- strings
- buffer-local vars
- I/O

** Implementation          10min
*** code
- byte-code
- bootstrap
- debugging
- profiling
- jit
- tail calls
*** data
- overview
- stack scanning
- tag bits
- vectors
- weak pointers
- incremental GC
- dumping

** XEmacs period           10min
- events&keymaps
- characters
- ffi
- aliases
- unicode
- bignums
- specifiers
- performance improvements
- Custom

** post-XEmacs             10min
- lexical scoping
- cl-lib
- pattern matching
- gv
- OO
- generators
- concurrency
- inline functions
- modules or lack thereof

** Conclusion               5min
- macros allow "wild" experimentation and domain-specific extensions
- simple core, with conservative evolution

* Mike

Issues:

- When to do "Stefan = Emacs, Mike = XEmacs"?
- How much of the Emacs vs. XEmacs history?
- Where to put free software ideals?

** Steele + Stallman: TECO => Emacs keybindings

Reenact the original scene.

** Lisp overview

Come from TECO language.

Then have a conversation.

"Obscure PL" vs. Scheme (academic) / Lua (didn't exist) / Python
(didn't exist) / Tcl (didn't exist) / JavaScript (haha)

** Dynamic binding: What is it good for?

Stefan can show what dynamic binding is good for.

Mike's a Schemer, so likes static binding -> early work in XEmacs.

Stefan: "So where is it now?"

Mike: "Research!"

Stefan: "Static scoping in Emacs implemented."

Mike: "Boring! What do you do for a day job?"

** Macros


** XEmacs vs. Emacs

Mike: It's 1990, Emacs is dead. ...

Mike: "We did this 20 years ago."
Stefan: "But look where we got without it."

- opaque datatypes
- portable dumper
- incremental GC vs. "we turn off the message"

** What's Next

"But isn't Emacs dead, given how old it is?"

Stefan can tell the native-codee story, Mike can complain.

** Free Software

Empowerment / Accessibility / Free Software

M: So Stefan, I noticed when we were working on the paper, you use
*only* free software, right?

S: Right.

M: Isn't that pretty extreme?

S: ...

M: What does Emacs Lisp have to do with these goals?

S: Well, the central goal of Free Software is to free users from the
restrictions of commercial software.

M: What do you mean restrictions?  Can't I just buy any piece of
software I want?

S: As long as that piece of software is Microsoft Office or SAP.

M: That seems to be what a lot of people want.

S: But it seems a waste of computers, the most adaptable machine in
human history, to only be used in a couple of ways.

M: Yeah, well, I work on a lot of digital-transformation projects, and
boy are people not served by stock software when that happens.  So I
understand how Emacs Lisp, being the language of Emacs, empowers
programmers to configure their IDE.

S: What do you use for e-mail, Mike?

M: Gnus in Emacs.

S: How do you organize your daily work?

M: org-mode in Emacs.

S: How do you write letters?

M: AUC-TeX in Emacs.

S: How does your administrative assistant write letters?

M: AUC-TeX in Emacs.

S: Now, other people in your office use Emacs, right?  Are their
setups all like yours?

M: No, they're completely different.

S: So Emacs - and Emacs Lisp - has empowered all of these people to
have a productivity tool that fits their needs.  Could that have been
achieved by just setting a bunch of configuration options?

M: No, there's a bunch of code in my init.el.

S: Get the point?

M: Yeah.  But it's still a restricted set of applications, right?
"Things that require an editor."

S: Well, at one point, German air-traffic control was running in Emacs
Lisp.

M: Was that a good thing?

S: Well, if you read it up, it really enabled folks on a clunky VMS
system to do high-level programming.  In one of the better-debugged
runtimes available.

M: But what if there'd been a bug in that runtime - with commercial
software, you can call support, and they'll fix the bug.

S: Ever tried that?

M: I was being sarcastic.  So with free software, you have what I
guess you'd call a fighting chance: If you can't fix a problem
yourself, you can hire somebody to do it.

I'll still point out that Emacs is mostly a tool for experts.  I'm
running a software company, we're all computer people.  When Stallman
founded the GNU project, he did it to empower users, but when he said
"user" he really meant "people who hang out at MIT lab".

S: If you look at the Emacs Lisp manual, you'll see that it's written
for programmer newbies.

M: Yeah, well´, I guess he was envisioning a future where more people
would routinely program.  That never happened.

S: None of Stallman's fault.  At least he tried, and if you're a user,
you at least have that chance you mentioned.
 

** XEmacs and Emacs

M: Hi, I'm XEmacs.  I'm glad you noobs finally figured out how to do
portable image dumping.  We did that 20 years ago.

S: But then you fell asleep at some point.

M: Yeah, well I fell asleep waiting for the GC in Emacs.  We have an
incremental GC.  You just turned off the message that tells users
Emacs Lisp is GCing.

S: You just had one of your students do the work on that one for
free.  You could have told him to do it in Emacs instead.

M: No, I couldn't.  Because you didn't have portable image dumping
figured out.

S: What does that have to do with it?

M: The portable dumper works from a uniform description of the object
layout.  The XEmacs GC uses the same uniform description to do pointer
tracing.  You have that now, right?

S: FIXME Stefan

M: Why didn't you implement that earlier?

S: FIXME Stefan

M: So what you're saying is that Emacs's internal architecture still
sucks, after all these years.

S: At least we're still around.  And speaking of architecture, we have
static scoping now, which you failed at.

M: At least we had data abstraction.

S: What is that supposed to mean?

M: You still use lists for keymaps, right?

S: Yeah, you have a problem with that?

M: Well, you invite people to just use list functions on keymaps,
breaking any abstractions you might have in place.  That means you can
never change the format.

S: Well, we *did* change the format a bunch of times.

M: And how did that go?

S: So how did you fix this problem in XEmacs?

M: XEmacs, from the beginning, had more *opaque* datatypes which you
could only manipulate using specific functions for that datatype.
Keymaps are an example.  This way, we can change the underlying
implementation without changing the interface.

S: Is that the reason you forked from Emacs?

M: No, that was because a company named Lucid needed a more advanced
version of Emacs for one of their products.  That version was supposed
to be Emacs 19, but it didn't come out for like forever.  So Lucid
made their own version.  It was called Lucid Emacs originally.

S: So it seems you did a bunch of things right technologically but
couldn't hold it together long enough.

M: Yup.  Fun times, though.

S: By the way, Mike - the Clojure folks seem to be doing the same -
expressing everything in terms of the built-in data types like lists
and vectors and maps, instead of defining new ones.

M: Yup.  Same mistake there.
