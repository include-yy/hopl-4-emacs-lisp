* General structure
Not sure exactly about ordering: most other HOPL papers follow a mostly
chronological organization, so I guess we could do the same?

However, HOPL 2 / Lisp has:

https://www.cs.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf

- History in terms of projects and people: XEmacs was going strong
  when Emacs wasn't

- Evolution of the language in technical terms

How 'bout:
1- prehistory (Mocklisp and Maclisp)
2- early history (Emacs until the big schism)
3- XEmacs
4- Emacs
Given that XEmacs's development was most active when Emacs's was most
dormant and vice-versa, this ends up being almost chronological.

* Sources
https://www.emacswiki.org/emacs/EmacsHistory
https://www.jwz.org/doc/emacs-timeline.html
https://www.jwz.org/doc/lemacs.html
https://www.xemacs.org/Documentation/21.5/html/internals_3.html
http://www.multicians.org/mepap.html
https://en.wikipedia.org/wiki/Mocklisp
https://www.gnu.org/gnu/rms-lisp.en.html
http://www.softwarepreservation.org/projects/LISP/embedded/#Emacs_Lisp_
https://www.math.utah.edu/docs/info/elisp_toc.html
ftp://ftp.gnu.org/old-gnu/Manuals/
* Projects and people
** Gosling Emacs/MockLisp
https://news.ycombinator.com/item?id=8727085
http://bitsavers.informatik.uni-stuttgart.de/pdf/cmu/Gosling_Unix_EMACS_Dec81.pdf

** Compiler rewrite by Jamie Zawinski / Lucid Emacs
- type opacity - keymaps, events?

** Other implementations
*** Elisp in MIT Scheme
 Edwin, there's also a paper on this:
 https://archive.org/stream/bitsavers_mitaiaimAI_794650/AITR-1451_djvu.txt
In "down with emacs lisp" you also mention JEmacs.
*** Elisp in Guile
*** Elisp in Common-Lisp (Sam Steingold?)

* Language & Implementation Overview
** ... usual stuff ...
** Buffer-local variables

** Comparison to other Lisps of the time

** Language implementation
** Interpreter
** Image dumping
** Byte-code architecture
** Bootstrap?
** C FFI
** JIT compiler attempts

* Language Evolution
** CL
** EIEIO/CLOS
** Opaque data types u XEmacs
** Text/character representation
** Keymps
** Static scope
Mention Neubauer/Sperber ICFP 2011 paper
** How 'bout evolution of typical programming style?
** frame-local variables?
** Evolution of the "core Elisp" language?
I'm thinking here of how when/unless/dolist/push/setf slowly migrated from
CL to subr.el in Emacs.
** Of course, I'd mention `pcase` in there as well
** lack of tail-call elimination?
** lack of modules?
** what about tooling?
*** docstrings (and checkdoc)
*** Edebug
*** Advice?
*** the various `declare` thingies
indent, debug, doc-string, advertized-calling-convention, ...

* Future evolution
** Multi-threading?
** OCaml extensions?
** Replacement by Scheme/Guile
** Replacement by Common Lisp
* Stallman feedback
  > We trace the overall evolution of Elisp in the software projects that
  > implemented it. Its predecessors EINE (1976) and Multics Emacs (1978)
  > were themselves written in Lisp.

** DONE I did some work on ZWEI, the second iteration of EINE.  In ZWEI (Zwei
   CLOSED: [2019-03-20 Wed 16:38]
Was Eine Initially), buffer-modifying primitives took arguments to
specify what text to operate on.  I found that clumsy, so in Emacs
Lisp I made them operate at point.

ISTR that in Multics Emacs, NO buffer primitives let the user specify
positions.  It was always and only operating at point.  I found that
too clumsy.  So Emacs Lisp has some primitives that operate where an
arg says, and some that operate at point.

** DONE > Emacs as we know it today itself started in early 1985.
   CLOSED: [2019-03-19 Tue 15:19]

 The original Emacs was dsveloped in 1976, by me with some help from
Guy Steele.

I started GNU Emacs around Sep 1984.

** DONE > Development continued at a high pace until about 1991. Around that time,
   CLOSED: [2019-03-20 Wed 16:43]
  > its development slowed down and was overtaken by Lucid Emacs, later
  > renamed XEmacs,

This is because Lucid hired the Emacs developer away from the FSF.

NOTE: I don't see supporting documentation for this - when Lucid Emacs
overtook Emacs, Joe Arceneaux was no longer working on the project.

** DONE > Arguably, the strongest
   CLOSED: [2019-03-20 Wed 16:38]
  > influences for Elisp were Gosling Emacs's Mock Lisp and MacLisp.

Nocklisp (that's how it was written)

NOTE (Mike): Gosling's manual for Unix Emacs says "Mock Lisp"

had very little influence, since I
decided very early to replace it with real Lisp.  In Mocklisp,
primitives all operated at point.  I made the corresponding features of
Emacs Lisp less clunky.

** DONE > Moreover, Richard Stallman, made the design of Elisp embody and showcase
   CLOSED: [2019-03-20 Wed 16:44]
  > the ideals of Free Software. For example, not only is it legal to get
  > and modify the source code, but every effort is made to encourage the
  > end-user to do so.

Indeed, there is no law saying that the user can't do this (because it is free
software, released under a free software license).  But is that what you mean?
Is "legal" the right word to use here?

** DONE > Some specialized control structures were missing in the original Elisp,
   CLOSED: [2019-03-20 Wed 16:45]
  > among them the `do` loop construct, and the accompanying `return` and
  > `go` forms for non-local control transfer.

The reason I left them out was to make Emacs work on Unix systems which had
just 1 meg of memory and no virtual memory.

** DONE > A feature supporting easy extensibility was
   CLOSED: [2019-03-20 Wed 16:46]
  > self-documentation through *docstrings*, described in
  > Section [4.4](#sec:docstrings){reference-type="ref"
  > reference="sec:docstrings"}.

These came from the original TECO-based Emacs.

** DONE > Interestingly (unlike MacLisp), `lambda` was not technically part of the
   CLOSED: [2019-03-20 Wed 16:47]
  > Elisp language until around 1991 when it was added as a macro, early
  > during the development of Emacs-19.

That is not correct.  Functions were lists starting with `lambda'
since the very beginning of GNU Emacs.

However, those lists did not self-evaluate until `lambda' was made
a macro.

** DONE > changes [@Stallman1981], but this feature was not provided in Elisp
   CLOSED: [2019-03-20 Wed 16:49]
  > because Richard Stallman considered it a misfeature, which could make it
  > difficult to debug the code. Yet this very feature was finally added to
  > Elisp in 2018 in the form of *variable watchers*, though they are
  > ironically mostly meant to be used as debugging aides.

This is not ironic.  We avoid using them as an extension mechanism
because that makes the code hard to debug.  Using them as a debugging method
does not have such a problem.

** DONE > Emacs-19, providing a `defadvice` macro duplicating a design available
   CLOSED: [2019-03-20 Wed 16:50]
  > in MacLisp and Lisp Machines, that allowed attaching code to functions
  > even if they do not run hooks.

It is bad practice to make a Lisp program put advice on another Lisp
program's function, because that is confusing.  When you see that the
program calls `mumble', it might take you hours before you think of
checking whether it has advice.

** DONE > During the learly years of Emacs,
   CLOSED: [2019-03-20 Wed 16:50]

typo,

** DONE > While Lucid at first tried to support and thus speed up the development
   CLOSED: [2019-03-20 Wed 17:04]
  > of Emacs 19, the required cooperation between Lucid and the Free
  > Software Foundation soon broke down.

The reason for this is that the Lucid Emacs team never discussed it
with me.  The head of Lucid wanted them to cooperate with me and the
GNU Project, but they did not even tell me that they were developing
on changes in Emacs until their version was finished.  My first
discussion with them about the design of their new features was after
that -- and their attitude was, "The code is free, use it if you want
it, but we don't care."

I liked some of their features enough to merge them into Emacs, for
instance the display features.  I did not like the extents, so I used
instead the text properties that Joe Arceneaux had been working on
(but he had left the code unfinished when he went to Lucid on short
notice).

NOTE (Mike): Dick Gabriel's account of that period in
https://www.jwz.org/doc/lemacs.html differs from this, so I think it's
likely best to elaborate on why that cooperation broke down at this
point.

** DONE I think that Lisp "module" systems based on distinguishing mu;tiple
   CLOSED: [2019-03-20 Wed 17:08]
symbols with the same abbreviated name inevitably work badly.
That was my experience with Common Lisp in the Lisp Machine.

Scheme's module system can work reasonably because it operates when determining
the binding of a symbol, not when reading the symbol.

NOTE (Mike): No historical note here.

** DONE > The vast majority of existing Elisp code was (and still is) agnostic to
   CLOSED: [2019-03-20 Wed 17:09]
  > the kind of scoping used in the sense that either dynamic or lexical
  > scoping gives the same result in almost all circumstances.

As written, this is not true.  Lots of Emacs Lisp programs bind global
variables that serve as parameters to certain operations.  They depend
on these bindings to be dynamic.

* Reviews
** Review #16A
===========================================================================

Overall merit
-------------
3. Weak accept

Reviewer expertise
------------------
2. Some familiarity

Paper summary
-------------
The paper describes the development of Emacs Lisp and related systems
such as XEmacs Lisp.  It is organised into "epochs"

   - Prehistory
   - Early history
   - Base language design
   - Base language implementation
   - XEmacs period
   - Emacs/XEmacs co-evolution
   - Post XEmacs
   - Alternative implementations

The paper often seems light on citations, often describing a whole
development with no citations, not even to its documentation. The
exposition often assumed knowledge I did not have, such as familiarity
with CLOS.

*** TODO The development is quite detailed, and I wonder how much interest it
will hold for the general community. There certainly are points of
interest.  The conclusion refers to "willingness to break backward
compatibility in specific cases" and "unbridgeable personal
differences, heated debates, and forks along the way".  I think a
paper of greater value and greater general interest could be derived
by structuring it around these issues, omitting much of the other
detail.

Comments for author
-------------------
*** TODO Please use author-year citations throughout.

*** TODO Many sections of the paper have no citations. In all these cases,
are we to assume there is no documentation and it is down to personal
knowledge of the authors? Please add citations wherever possible.

*** TODO Throughout, I had a lot of trouble mapping release numbers to
years, and relating release numbers for Emacs to those for XEmacs.
Could you give a table with a chronology of releases?

*** TODO Why are you two the right ones to write this paper? Please say in
the introduction a little about your involvement with Emacs and
to what extent (if any) you consulted with the community in writing
this paper.

*** TODO Also, bring out some details about the people involved. For instance,
you should say something regarding Stallman's biography. He is
mentioned with regard to specific details, but you should also say
something about his overall role in the history.

*** TODO Occasionally you refer to the Emacs community in the first person.
I recommend you use third person throughout.

*** DONE p4, Section 3
    CLOSED: [2019-03-24 Sun 11:16]
"Following Greenberg's Multics Emacs" Citation please!

*** DONE "Greenspun's tenth rule" Citation please! Not all your readers will
    CLOSED: [2019-03-24 Sun 11:23]
know it.

*** DONE p5, Section 4
    CLOSED: [2019-03-24 Sun 11:57]
This section says nothing about lexical vs dynamic scope. As dynamic
scope seems a pretty backward design choice for 1985, it would be
helpful to say something about why it was chosen.  (This is finally
discussed in 8.1. Moving some of that discussion ahead, or at least
giving a forward pointer, would help.)

*** DONE p5, Section 4.1
    CLOSED: [2019-03-24 Sun 12:27]
A word on *why* lambda was omitted would be helpful. Can you interview
Stallman?  It's a little weird that you show in detail the syntax for
the Emacs-18 workaround, but you don't describe the Emacs-19 macro.

*** DONE p6
    CLOSED: [2019-03-24 Sun 12:27]
"With buffer-local variables" --> "Along with buffer-local variables"

*** DONE p7
    CLOSED: [2019-03-24 Sun 12:37]
"It could either denote ..." Please rephrase. I guess one of these
means (` a) and one means (`a), in the old-style notation,
but I can't tell which is which.

*** DONE p8
    CLOSED: [2019-03-24 Sun 12:40]
"has to do with region selection" This is mysterious---how does the
region affect this function?

*** DONE p9
    CLOSED: [2019-03-24 Sun 12:43]
"run a hook" Please explain what this means. I'm guessing it means to
execute each function in the list. Are the functions required to take
no arguments, or, if they have arguments, which are passed?

*** DONE "attaching code to functions even if they do not run hooks" Does this
    CLOSED: [2019-03-24 Sun 15:20]
attach a single function to another function? Or a list of functions,
as in a hook? Does the attached function run before the other function,
or at some other time?

*** TODO Stefan "makes better use of existing language features" Obscure. Explain or
give a citation.

*** TODO I could not discern an order to the subsections of Section 4. Possibly
best to reorder them, with the ones directly related to Emacs first
(e.g., 4.2, 4.5, 4.7, 4.9), then ones tied to Emacs goals (e.g., 4.4,
4.8), and the ones that are only incidental later (e.g., 4.1, 4.3,
4.6).

*** TODO p10 Section 5.1
Who developed the byte-code compiler? Citations, please.

*** DONE p11
    CLOSED: [2019-03-24 Sun 15:24]
"FSF-owned" I guess this is the Free Software Foundation?
But you haven't mentioned it by name at this point.

*** DONE p12
    CLOSED: [2019-03-24 Sun 15:25]
"where amply sufficient" --> "were amply sufficient"

*** TODO Stefan "the "mark" bit was not used" I'm confused. If it wasn't used for this
purpose, how were objects marked?

*** DONE "each object by allocated" --> "each object be allocated"
    CLOSED: [2019-03-25 Mon 11:01]

*** DONE If there are just eight object types, perhaps it would be
    CLOSED: [2019-03-25 Mon 11:13]
worthwhile to list them all?

*** DONE "merged that data representation of Emacs 19.30" I can't work out what
    CLOSED: [2019-03-25 Mon 11:13]
this phrase refers to, please rewrite.

*** TODO p13
"ephemerons" Are these so uninteresting that they deserve no
description in the paper?

*** DONE p14
    CLOSED: [2019-03-25 Mon 11:14]
"no matter which tagging scheme we used" Change from first to third
person.

*** TODO "tweaked to use two tags for integers" Link this to the odd and
even fixnum tags mentioned earlier.

*** TODO "cl.el's defstruct" What is cl.el? I guess it is a library inspired
by Common Lisp, but you ought to be clear about this.

*** TODO p15
"the more standard forms of weak references" I don't know what this
means.

*** DONE "very early" Is Emacs-16.56 really very early?
    CLOSED: [2019-03-25 Mon 11:15]

*** DONE p16
    CLOSED: [2019-03-25 Mon 11:16]

*** DONE Section 5.10.  End first paragraph with the sentence "Modifying
    CLOSED: [2019-03-25 Mon 11:16]
function bodies was brittle and inconvenient and only worked for
functions defined in Elisp." Delete the similar phrase from the next
paragraph.

*** DONE p17
    CLOSED: [2019-03-25 Mon 11:17]
"but did get" --> "But it did get"

*** TODO "stable enough to be used globally" What does this mean? (I gather it
does not mean the feature was released, since it is still an
attmempt.)

*** DONE "compared to Nickolas" --> "compared to Lloyd"
    CLOSED: [2019-03-25 Mon 11:34]

*** TODO Section 6. Since Xemacs has been referred to throughout the paper,
it would be best to move the information in the first three paragraphs
of Section 6 to before Section 4.

*** TODO Footnote 3. What was the release number of the first release of
Lucid Emacs?

*** TODO p18
Section 6.1. I gather the purpose of a keymap is to map a
sequence of keystrokes to a function to invoke. Please say this
explicitly. Please also explain nesting of keymaps.

*** TODO "inheritance" I don't know what inheritance means in the context of a
keymap.

*** TODO "SFEmacs" Perhaps say a word or two about why this fork came
into existence?

*** TODO p20
"While no significant changes were made to the byte-code format in
XEmacs, the two instruction sets eventually drifted and became
incompatible." Surely the first incompatible change was significant,
just because it was incompatible? Make clear whether the drift was a
deliberate choice or an accident.

*** TODO p21
"it was not unified with other charsets" I don't know what this means.

*** TODO p22
"This issue is still being discussed with Emacs." --> "This issue is
still being discussed in the Emacs community."

*** TODO Section 7.4. Why are the three displayed examples given? This seems
more detailed than other discussion, and it seems more detail than
necessary.

*** TODO p23
"during that time" Unclear. Replace by "post-2010" or whatever is
correct.

*** TODO The summary of Section 8 at the beginning omits 8.2 and 8.3.

*** TODO ""hidden" configuration options" I'm not sure what "hidden" adds
here, perhaps delete?

*** TODO p24
"except in the presence of higher-order functions, like reduce" I
don't understand why higher-order function would lead to name
conflicts under the described convention.

*** TODO p25
I take it that in the current version lexical scope is the default,
but that dynamic scope is still possible. You should say something
about how this is achieved. You should also say how backward
compatibility was maintained. Was this done by static analysis
or two languages, both described previously, or by some other means?
How smoothly did the introduction of lexical scope go?

Has lexical scoping made its way into XEmacs?

*** TODO p26
"often using the new low-level pattern app". I have no idea
what this means. Explain or omit.

*** TODO p27
"we" Perhaps change to third person?

*** TODO p28
I take it that both cl.el and cl-lib.el are currently in use.
Does this introduce any performance or maintenance issues?
Are there plans to deprecate cl.el?

*** TODO Section 8.5. Previously, the text used "generalised reference"
but now it uses "generalised variable". Perhaps change the earlier
occurrences of "generalised reference" to "generalised variable".

*** TODO "can be used as an ... and an ..." --> "can be used both as an ... and
as an ..."

*** TODO "(VARS VALS STORE-VAR STORE-FORM ACCESS-FORM)" I don't follow this
explanation. How does STORE-VAR relate to VARS? The expansion of
(push EXP PLACE) helps little unless the reader knows how push
is defined. This paragraph should be rewritten with more explanation.

*** TODO "NIH syndrome" That seems a different reason that "the existing
code was hard to follow"!

*** TODO "wanted to keep in cl.el" --> "did not want to move to Emacs"

*** TODO "cl-lib" in italic --> "cl-lib.el" in tt foont

*** TODO "a DO function of two arguments" Is this what is called
gv-get-place-function in the following example? Please rewrite
to clarify.

*** TODO p29
Nothing is gained by giving two forms of the push example.
Just give one or the other.

*** TODO p29
"the reverse is not true" Why can't you set
  (VARS VALS STORE-VAR STORE-FORM ACCESS-FORM)
to
  (nil nil x (STORE-FUNCTION x) ACCESS-FORM)
?

*** TODO "(originally developed in 1986 by Cesar Quiroz, and included in
Emacs-18.51 in 1988)" Doesn't belong here. Add the last phrase
to the earlier mention of cl.el on p26.

*** TODO "CLOS" Give a citation for CLOS, and explain it is the
Common Lisp Object System.

*** TODO "(a package providing IDE-like features)" move this to the
mention of CEDET in the previous paragraph.

*** TODO p30

"supported specializers" I'm not familiar with CLOS, and I don't know
what a specializer is. Please explain. Indeed, please rewrite the
whole section assuming your reader is not familiar with CLOS.

*** TODO “&context (EXP SPECIALIZER)” I'm completely lost here. Help!

*** TODO Are the object facilities of both EIEIO and cl-generic.el currently in
use?  Does this introduce any performance or maintenance issues?  Are
there plans to deprecate EIEIO?

*** TODO p31
"the generator.el" --> "generator.el"

*** TODO "in order to avoid it the coder needs to write their code in a
continuation-passing style" I don't see why this should be the case,
please explain.

*** TODO p32
"async.el" Cite its documentation.

*** TODO A word or two on uses of the concurrency package would be welcome.
Have the uses led to concurrency bugs? If there aren't many uses
of the package yet that would also be valuable information.

*** TODO "is important to optimize for example" --> "performs important
optimizations, for example"

*** TODO "the macro can extract" Which macro??

*** TODO The story seems to stop early. Did define-inline solve the cl-typep
problem? How? How widely used is define-inline? How does it co-exist
with the older systems for inlining?

*** TODO p33

"¡pkg¿" font issue?

*** TODO p34

"Emacs-Ejit" I presume this is the compiler from Emacs to Javascript?
Please make this explicit.

*** TODO p35

"willingness to break backward compatibility in specific cases" It would
be good to make this a theme of the paper, stressing where it happened,
how the evolution was handled, and how successful it was.

*** TODO "unbridgeable personal differences, heated debates, and forks along
the way" These are all great topics for a history! But the paper largely
ignores or downplays these.

*** TODO "But it has also come up with its own features" Interestingly, all three
that you list are already covered in Section 4! Were there later ones?

*** TODO "whose composability" Rewrite the sentence so it is clear you are talking
about the composability of packages, not of the community.


** Review #16B
===========================================================================

Overall merit
-------------
2. Weak reject

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
This paper describes the design and implementation of the Elisp language as
part of the Emacs text editor over the course of thirty years.

Comments for author
-------------------

ASSESSMENT

Overall, this paper is not yet ready for HOPL in its current state. Perhaps
with shepherding it could be made acceptable, however, it will take a lot of
work.

The biggest problem with this paper is that it does not tell a compelling
story. It is a historical account, but much of its telling lacks any
discussion of context. It covers a lot more ground describing *what* happened,
but does not explain *why* it happened or what the result was. I think the
issue is that the authors have favored breadth over depth--a lot of changes
have been made to Elisp since 1985! But it is the job of the authors to
identify the most important changes and events, so that they can make their
points.

The best part of the story is when the paper talks about the interactions
between the designs of the language and the constraints of being the scripting
language for an editor, and of the constraints that come from being part of
the free software movement. I wish this part of the story were told more
consistently and more prominently.

*** TODO In contrast, many evolutionary changes are presented without discussion or
analysis. I can only assume that the there were other reasons for these
changes, besides the two listed above, but I would rather not have to guess.

*** TODO Indeed, many parts of the paper read like a changelog. Throughout these
sections, I found myself wondering, what should I take away from this section?
What can I learn from it? How does it fit into the overall story? In
particular, although it is notable that some features that require primitive
support in other languages can be implemented via macros in Elisp
(e.g. lambdas, objects, pattern matching, generators, modules) this is also
true for other LISP variants. What is unique here? Perhaps it would be better
to focus on the ones that have more close connection to Elisp----for example,
the ones that are difficult to implement in the presence of dynamic binding.

*** TODO Dynamic binding is itself one of the most famous (mis-)features of Elisp, and
I wish the paper described this feature & the introduction of static binding
in a more self-contained way, rather than scattering it throughout the text. I
also wish that it were more complete. What were the initial advantages of
dynamic binding? What made static binding ultimately possible? How has the
change affected the community?

*** TODO Another issue with the paper is that it is targeted to Elisp experts. As a
casual Emacs user for over twenty years (I am using it now to type this
review), I have encountered some of Elisp, and as a programming language
researcher, I am curious about its history. However, some parts of this paper
assume the knowledge of an Emacs developer! Why not broaden the audience and
make the paper more accessible?

SPECIFIC COMMENTS and ADVICE

*** TODO - In scientific papers we often keep ourselves out of the story, as the
  scientist should be a independent observer. But that isn't the case for
  history. Please introduce yourselves at the beginning of the paper and lay
  out your connection to the material. This lets the reader better put this
  material in context---are you telling us material that you have first hand
  knowledge of because you were there, or is this something that you heard
  from someone else?

*** TODO - Overall, I kept confusing the description of Elisp the language with the
  description of Emacs the software artifact. I believe this is a deliberate
  choice by the authors to blend these descriptions, and is probably
  justified, but at the same time it left me off kilter.

*** TODO - I would appreciate a timeline or figure near the beginning of the paper that
  outlines the major milestones in the development of Emacs. In particular,
  the discussion lists various version releases (e.g. Emacs-24.3) without
  providing dates for these releases. Also, sometimes the discussion includes
  a minor number with the release (e.g. Emacs-19.29) and sometimes it doesn't
  (e.g. Emacs-19). Is there a semantics to the major/minor numbers of the
  release?

  This timeline, and a capsule summary of the major software artifacts discussed
  in the paper, will help later discussion immensely.

*** TODO - The paper needs a short introduction to who Richard Stallman is, what the
  free software movement is, and what the GPL requires. Although many readers
  may already know this story, establishing the details that are important to
  later design decisions is a good introduction. Instead, the first time
  Stallman is *introduced* is the sentence "Richard Stallman decided to
  reimplement the basis for the new Emacs in C..." which I found really
  confusing. What was his first implementation?

*** TODO - In fact, I found the entirety of Section 2 (PREHISTORY) confusing. It is too
  short and jumps around too much. The introductory sentence "While Emacs's
  original inception was a set of macros for the TECO editor" puts me off
  right from the start. Should I know what the TECO editor is? Was this the
  first thing ever called Emacs?  Who created the name Emacs and where did it
  come from? (Or is it lost to history?) The two sub-sections in section 2
  also do not add much beyond what has already been said. What is the
  relationship between EINE and MacLisp?  (And MacLisp is a programming
  language, not an editor, right? Is the editor that was written in MacLisp
  the one later called "Greenberg's Multics Emacs"?) How did MacLisp influence
  Elisp?

  In 2.2, what do you mean when you way "Unix Emacs ... was one of the
  immediate predecessors of Emacs"? What is the specific software package that
  you are referring to with the name "Emacs" at this point. Who wrote it?
  When?

*** TODO - Section 3. When was Stallman's Emacs (and Elisp) developed and released?

*** TODO - Please be careful with the use of "in jokes" such as "Greenspun's tenth
  rule" and "Eight Megs And Constantly Swapping". These are both presented as
  if the reader is already familiar with them, which is a way to turn off
  readers. Mentioning them without explanation gives the impression that you
  only expect people already familiar with them to read this article. How
  limiting!

*** TODO - I generally find "table of contents" sections, such as the one right before
  4.1, to be boring, repetitive and unhelpful. I never read them.

*** TODO - 4.1: What is the time period/Emacs versions covered in Section 4? What are the
  consequences of lambda being a macro. Why wasn't the original Elisp code
  ever updated to use this new lambda form over 30 years?
  What is the #' ... reader shorthand referred to at the end of page 6?

*** TODO - 4.2: I was confused by this section, especially since the discussion seems
   to be split between it and 4.7. What are buffer local variables? How does
   that make strings a fancier datatype than in most other languages?  What is
   the impact of storing strings with variable numbers of bytes? Why is moving
   the string's bytes elsewhere on update an issue? Why is XEmacs
   "modified-tick" feature worth mentioning when it has apparently never been
   used?

*** TODO - 4.3: This section is an example of the Emacs communities' approach to
  backwards-incompatible changes, which is both tedious in detail but leaves
  me wanting to know more. What is the context of the design changes discussed
  in this section (i.e. introducing explicit warnings in Emacs-22.2)? How did
  users react to them? What changed so that the old-style syntax could be
  removed in 2018? Why could it not be changed earlier?

*** TODO - 4.4: Is there more to say about the docstring feature? Has it been studied
  by language designers? Are there trade-offs in including this feature in
  Elisp? What percentage of Elisp code uses docstrings? How searchable is it?
  What other languages, besides Common Lisp, have adopted it?

*** TODO - 4.5: "C-u (to specify powers of 4)" ? What is this design? Why powers of 4?

*** TODO - 4.6: How does Elisp's support for non-local exits compare to other language
  features, like exceptions? What influenced the design? (It appears to be
  constraints of general purpose software engineering, right? Nothing specific
  to the context of Emacs...)

*** TODO - 4.8: Is the defadvice feature used in practice? How? How was nadvice
  different? What sort of advance was it?

*** TODO - Section 5: "The main changes were those made to support lexical scoping..."
  I wonder if focusing on the dynamic to lexical scoping evolution would make
  for a tighter, more compelling read.

*** TODO - Section 5: I found this section, which mainly focuses on changes to the
  implementation of Elisp, underwhelming. Partly it is my biases --- most of
  these changes are invisible to users, except when they remove limitations on
  heap size and file size. However, partly this is because this section does
  not discuss the context of these changes. What pressures were in play? How
  did changes, to say, data representation, affect users? libraries? runtime?
  FFI?

*** TODO - 5.7: "These were solved very simply in Emacs-19.31 by removing messages that
  indicated when GC was in progress." This sentence, presented with minimal
  discussion, makes me sad. Sure, user complaints about GC decreased as a
  result, but is that because users were deceived? Or were the messages
  incorrect? Or were the user perceptions wrong to begin with? Was this the
  right thing to do?

*** TODO - 6.1: Am I supposed to understand the keymap representation from this
  example? What is important about the current representation? Overall, the
  discussion in this section is one of software engineering experience: should
  a particular data structure in the implementation of Emacs be represented
  concretely or abstractly. How does this relate to the design of Elisp?

*** TODO - In the middle part of the paper, we start to see the introduction of new
  characters, as the development team grows. However, there is no high-level
  discussion about how the development teams for Emacs and XEmacs were
  composed, lead and organized. Were they both open-source projects? How big
  were the teams? Did Stallman always control everything to do with GNU Emacs?
  How did the teams communicate with each other (if they did so)?

*** TODO - 8.4: The timeline of integration of common lisp functions into Elisp seems
  uninteresting and really reads like a changelog. I have no idea what these
  functions are or why their integration is important.

*** TODO - 8.11: The fact that still Elisp rejects a module system because the
  developers don't want to rely on an IDE makes me despair as a language
  researcher. If any language can make assumptions about its development
  environment...

*** TODO - Section 9: This section reads like a laundry list, or a "we didn't want to
  offend anyone by leaving them out". As a reader, I didn't get much out of
  it.

*** TODO - Section 10: The conclusion should never introduce new material. Yet, I don't
  see where "a maintainership which was more interested in improving the text
  editor than the language" was discussed earlier in the paper. What actions
  is this comment in reference to? The paper also is rather oblique about
  discussing the "unbridgeable personal differences, heated debates, and forks
  along the way". This is the place to record the controversies, right or
  wrong, as they are part of the history.


** Review #16C
===========================================================================

Overall merit
-------------
5. Strong accept

Reviewer expertise
------------------
2. Some familiarity

Paper summary
-------------
The paper traces the evolution of ELISP as the Lisp based macro
facility of Emacs.  It discusses the language evolution, but more than
that how the system that it was a part of evolved over time...and how
the system often changed the language more than the language designers
did.

Comments for author
-------------------
I enjoyed this paper a great deal.  It told the story of ELISP and how
it changed and evolved over time...driven by the needs of Emacs, of
the open source community, of different views of development
environments and tools (like debuggers and operating systems).  It
treats the language design, performance optimizations, surround
features/environemnts as parts of the "whole" and I really like that
approach.  The personalities involved, especially the influence of
Stallman, comes through - which is nice for an open source project
that doesnt have the usual corporate funding/management issues that
Jean Sammet used to ask about in earlier HOPLs.

At this point my main complaint is that the paper attempts to bring
the history up the present day and even hints at future plans...a
natural thing to do, but probably not right for a history paper.
There are a few obvious typos to that will have to be fixed.

** Review #16D
===========================================================================

Overall merit
-------------
4. Accept

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
This paper describes the evolution of emacs lisp, from its very beginnings to the present day.  The paper describes design and implementation changes, along with much of the background motivation and underlying politics.

Comments for author
-------------------
I found this very interesting and overall an informative and enjoyable read.   I enjoyed your writing style and the touches of humor.    I enjoyed hearing the background to various technical decisions and some of the politics that under pinned the decisions.

I have only two suggestions

### Summary

*** TODO I think it might be helpful to provide a summary (before the conclusion), summarizing some of the key elements of the story and highlights of the journey, in the form of a high-level re-cap.

### Lessons

I think there are quite a few lessons for language developers here.   It may be worth drawing them out as such.   This could be done in-place, or it could be done by including a list of lessons in the summary section.   I am thinking here about lessons at all levels: open source software culture and how it affects the development and evolution of the language; the extent to which engineering pragmatics ultimately impact language design; the roles or personalities; the overall impact of the XEmacs split.   Etc.

*** TODO - I liked your point (p11) about the chicken-and-eggs nature of the TOC problem.   I think this is a very common pattern in systems implementation.

*** TODO - Your comment (p21) about the limited impact of optimizations where the underlying byte-code interpreter is slow, is interesting and probably common to many language implementations.

### Minor

*** TODO - It would help your reviewers if you could include line numbers on the page (a feature which comes with the latest style files).   This makes it very easy for us to precisely communicate references to the text.
*** TODO - p5 "with a technical" -> "with technical"
*** TODO - p5 "in the inclusion in Emacs of" this is awkward
*** TODO - p5 "a Lisp-2" -> "a Lisp-2 language"
*** TODO - p6 "Richard Stallman felt" it would be great if you could provide references to such comments (I understand that this may not be possible).
*** TODO - p6 "With buffer-local" -> "Along with buffer-local"
*** TODO - p6 "requires to relocate" -> "requires relocating"
*** TODO - p7 "Emacs-27 the" -> "Emacs-27, the"
*** TODO - p9 "used etc." -> "used, etc."
*** TODO - p9 "instead because" -> "instead, because"
*** TODO - p11 the comment connecting bootstrap with RCS -> CVS transition is interesting, but needs a little bit more information.   The reader may not understand that RCS required local operation, while CVS did not.   Its not clear why the necessary files could not be kept around in CVS, nor how the original bootstrap began (answer on next page---the interpreter).
*** TODO - p12 "32bit" -> "32 bit" (systemic)
*** TODO - p12 "mark&sweep" -> "mark and sweep" (systemic)
*** TODO - p12 "heap size" this term is used widely to mean the size of the heap (how much memory is available to or consumed by the whole heap).   However, here you mean something like the heap footprint of a given object.   Sometimes in the GC literature, the word 'cell' is used to describe the space taken up by an object (inclusive of metadata etc).  systemic).
*** TODO - p12 "where were the fields" -> "where the fields were"
*** TODO - p13 "256MB" -> "256 MB" (use a thin space, eg \;) (systemic)
*** TODO - p13 "3-word" -> "three-word"
*** TODO - p13 "four: records" -> "four records:"
*** TODO - p14 "hence pushing" -> "pushing"
*** TODO - p14 "learly" -> "early"
*** TODO - p14 I like the anecdote about GC pauses!
*** TODO - p16 "show a an" -> "show an"
*** TODO - p17 "affect function calls" what does this mean?  Are you referring to inlining?
*** TODO - p17 "costly. but" -> "costly. But"
*** TODO - p17 "used globally" what does this mean? (again later in the page)
*** TODO - p17 "it focuses" what focuses?
*** TODO - p18 "Lucid Emacs of Lucid Emacs" -> "Lucid Emacs"
*** TODO - p19 "Characters outside of strings" can you elaborate?
*** TODO - p19 "into running" -> "into a running"
*** TODO - p19 "Richard Stallman refused to..." can you provide a reference?
*** TODO - p20 "rewrite, " -> "rewrite"
*** TODO - p21 "evolved" -> "evolved,"
*** TODO - p21 ",," -> ","
*** TODO - p22 "set variable" -> "set a variable"
*** TODO - p23 "Emacs-26.1" -> "Emacs-26.1,"
*** TODO - p27 "efficiency cost" -> "overhead"
*** TODO - p28 "NIH" -> "Not invented here"
*** TODO - p30 "only it was" -> "only was it"
*** TODO - p30 "machinery, required" -> "machinery required"
*** TODO - p30 "to explore interactively" -> "to interactively explore"
*** TODO - p31 "already in Emacs-16.56 Emacs" -> "by Emacs-16.56, Emacs"
*** TODO - p31 "all of existing" -> "all existing"
*** TODO - p31 "it the" -> "it, the"
*** TODO - p32 "This result" -> "The result"
*** TODO - p33 latex problem with one use of <pkg> (forgot to protect < and >)
*** TODO - p35 "general the" -> "general, the"
*** TODO - p35 "contributions of course" -> "contributions, of course"

* Questions
** RMS
*** Why was lambda-as-a-macro only added so late?
*** When was the byte-code compiler added?

** Brent
*** How do we "cite" revision-control records?
*** How do we deal with disputed history?
*** How relevant is history with impact on Emacs but not on Emacs Lisp?
*** Should we explain more of core Emacs Lisp instead of deferring to the MacLisp manual?

* Conf calls

** 2019-02-28 w/ Brent Hailpern

- Story that tells a story that teaches something

- move to appendix stuff without human or organizational motivation

- good: constrained to make editor better

- highlight: how it evolved to make the macro experience better

- why is RMS important?

- why were we important?

- What was Emacs like?

- Evolution from TECO to Emacs Lisp

- Step 1: Fill in context, get the story

- LGPL came out of Lucid negotiations

- more background on Emacs

- Lua paper in HOPL III

- free software ... "boxes on the side"
[ Mike: I don't understand what this means.  ]

- tell several sub-stories

- TECO : find serious macro writers

- more interviews

- interview with Dick Gabriel, LGPL

- insist on the general human organization
  (e.g. the fact that it was controlled neither by a company nor
  a standards committee)

- talk more about the importance of having a real language

- design decisions that didn't work

- accumulation of hacks
[ I don't know what I meant by that!
  Mike, by any chance, does that ring a bell for you?  ]

* Interview questions
Here are things that maybe we'd like to know:
- how was Emacs's development organized before Emacs-21

